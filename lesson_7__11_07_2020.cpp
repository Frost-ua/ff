//#include<iostream>
//#include<math.h>
//#include "ctime"
//using namespace std;
//                                                 ==================== СОРТУВАННЯ БУЛЬБАШКОЮ ======================
//
// порівнюємо індекс масиву з наступним індексом, якщо 0-й індекс більший за 1-й, то міняємо їх місцями, якщо ні порівнюєм з наступним (2-м)
// індекс з більшими даними постійно пеміщається в кінець масиву - спливає як бульбашка
// масив сортується зправа масиву на ліво, з максимального значення (справа) до мінімального (зліва)
// ми можемо сортувати і навпаки зліва на право. Для цього ми порівнюєм останній індекс з попереднім, якщо дані останнього індексу менші 
// ніж попереднього, то міняємо їх місцями. Таким чином мінімальні дані рухаються на початок масиву
//
//void main() {      
// неоптимізований варіант
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 10;
//	int arr_A[SIZE];
//	int temp = 0;
//
//
//	for (int i = 0; i < SIZE; i++) {                      //заповнення рандомними числами
//		arr_A[i] = rand() % 50;
//	}
//	cout << "Unsorted array: " << endl;
//	for (int i = 0; i < SIZE; i++) {                        //виведення НЕ відсортованого масиву
//		cout << arr_A[i] << " ";
//	}
//	cout << endl;
//
//--------------------------------------------алгоритм сортування------------------------------------------
//
//	for (int i = 0; i < SIZE - 1; i++) {                       //два цикли. Зовнішній  проганяє кожен індекс масиву
//		for (int j = 0; j < SIZE - i - 1; j++)                 // внутрішній перевіряє чи 0 індекс більше 1- го і т.д
//		{                                         // пишем (SIZE - i - 1) для того щоб не перевіряти останні індекси, вони вже відсортовані     
//			if (arr_A[j] > arr_A[j + 1]) {                   // якщо 0-й індекс більше 1-го
//
//				temp = arr_A[j];                             // то ми 0-й індекс поміщаємо в тимчасову змінну "темп"
//				arr_A[j] = arr_A[j + 1];             // потім дані з 1-го індексу (оскільки він менший) поміщаєм в 0-й і т. д.
//				arr_A[j + 1] = temp;                     // і потім ті дані, які були в 0-му індексі (більший) поміщаємо в 1-й
//			}
//		}
//
//	}
//	cout << "=============================" << endl;
//	cout << "Sorted array: " << endl;
//	for (int i = 0; i < SIZE; i++) {                        //виведення відсортованого масиву
//		cout << arr_A[i] << " ";
//	}
//	cout << endl <<endl;
//	system("Pause");
//}
//
//
//
//
//======================================  оптимізований варіант, порівняння з неоптимізованим  ========================================================
//
//
//
//
//
//void main() {
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 20;
//	int arr_A[SIZE];                            // сортуємо оптимізованим алгоритмом
//	int arr_B[SIZE];                            // сортуємо НЕоптимізованим алгоритмом
//	bool flag = true;        // булева змінна - флаг, з його допомогою перевіряємо чи мінялися індекси місцями - функція SWAP
//	                         // щоб не виконувати лишні іттерації. якщо не мінялися індекси - брейк
//	int count_A = 0, count_B = 0;       //счетчики для підрахунку іттерацій для кожного з алгоритмів
//
//	for (int i = 0; i < SIZE; i++) {    // заповнюєм масив А
//		arr_A[i] = rand() % 50;
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_B[i] = arr_A[i];                 // Копіюєм масив А до масиву В
//	}
//	cout << "==========================================================" << endl;
//	cout << "Optimized algorithm: " << endl << endl;
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";                      //виводимо невідсортований масив А (оптимізований)
//	}
//	cout << "\t\tUnsorted array" << endl;
//	
//	for (int i = 0; i < SIZE - 1; i++)       // Сортування бульбашкою (оптимізований алгоритм) з флагом
//	{          
//		flag = true;
//		for (int j = 0; j < SIZE - i - 1; j++)    //пишем (SIZE - i - 1) для того щоб не перевіряти останні індекси, вони вже відсортовані 
//		{  
//			if (arr_A[j] > arr_A[j + 1]) {
//				swap(arr_A[j], arr_A[j + 1]);     // функція, яка міняє індекси місцями - 0-й (більший) переносить в 1-й
//				                                  // а 1-й в 0-й, змінна "темп" уже не потібна    
//				flag = false;                      // флаг ставим в фолс - індекси помінялися місцями, цикл працює далі            
//			}
//			count_A++;                        //збільшили каунтер на 1 (одна іттерація) - рахуємо к-ть іттерацій
//		}
//		if (flag) {                       // перевірка, якщо функція SWAP не зпрацювала (індекси не помінялися), робим брейк
//			break;
//		}
//		
//	}
//
//	for (int i = 0; i < SIZE; i++)         // виводимо відсортований масив А (оптимізований)
//	{
//		cout << arr_A[i] << " ";
//
//	}
//	cout << "\t\tSorted array" << endl;
//	cout << endl;
//	cout << "Iterations (Optimized algorithm)     -       " << count_A << endl; // к-ть іттерацій (оптимізований)
//	cout << "==========================================================" << endl;
//
//	cout << "Unoptimized algorithm: " << endl << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_B[i] << " ";                      //виводимо невідсортований масив B (НЕоптимізований)
//	}
//	cout << "\t\tUnsorted array" << endl;
//
//	for (int i = 0; i < SIZE - 1; i++) {
//		for (int j = 0; j < SIZE - i - 1; j++)
//		{                                               //Сортування бульбашкою (без брейка - НЕоптимізований алгоритм)
//			if (arr_B[j] > arr_B[j + 1]) {                // Буде більше іттерацій
//
//				swap(arr_B[j], arr_B[j + 1]);
//				
//			}
//			count_B++;                                   // рахуем к-ть іттерацій
//		}	
//
//	}
//
//	for (int i = 0; i < SIZE; i++)                 // виводимо відсортований масив В (НЕоптимізований) 
//	{  
//		cout << arr_B[i] << " ";
//		
//	}
//	cout << "\t\tSorted array" << endl;
//	cout << endl;
//	cout << "Iterations (Unoptimized algorithm)     -     " << count_B << endl;
//	cout << "==========================================================" << endl;
//	cout << endl;
//	system("Pause");
//}
//
//
//
//
//
//
//
//
// Заповнити масив англійськими буквами (використати таблицю символів АСКИ), знайти індекс введеної букви
//
//void main() {
//		srand(unsigned(time(NULL)));
//	
//		const int SIZE = 26;
//		char arr_A[SIZE];
//		
//		char temp;
//		bool c = true;
//		int count = 0;
//		
//
//		for (int i = 0; i < SIZE; i++) {
//			arr_A[i] = 65 + rand() % 26;          //рандомна буква - відповідно до таблиці АСКИ
//		}
//		
//	
//		for (int i = 0; i < SIZE - 1; i++) {
//			c = true;
//			for (int j = 0; j < SIZE - i - 1; j++) {  
//				
//				if (arr_A[j] > arr_A[j + 1]) {
//					swap(arr_A[j], arr_A[j + 1]);
//					
//					c = false;                                  //Сортування бульбашкою (з брейком)	
//				}
//				count++;
//			}
//			if (c) {
//				break;
//			}
//			
//		}
//		cout << "=============================" << endl;
//	
//		for (int i = 0; i < SIZE; i++) {                             
//			cout << arr_A[i] << " ";
//			
//		}
//		cout << endl;
//		cout << "Iterations - " << count << endl;
//		cout << "=============================" << endl;
//		cout << "Enter letter: \n";
//		cin >> temp;                             // введена буква
//		bool n = true;
//	
//		for (int i = 0; i < SIZE; i++)  // в циклі перевіряємо відповідність кожного індекса нашій введеній букві
//		{
//			if (temp == arr_A[i])      // якщо дани в змінній "темп" = даним в конкретному індексі - виводимо букву і індекс
//			{
//				cout << "Leter = " << temp << ", Indeks = " << i << endl;
//				n = false;
//				break;
//
//
//			}
//		}
//		if (n == true)     // якщо такої букви нема - виводимо - не знайдено
//		{
//			cout << "Not found" << endl;
//		}
//		system("Pause");
//	}
//		
//		
//
//
//
//
//
//                                 ==================== СОРТУВАННЯ ВИБОРОМ ======================
//
//
//
//
//
//
//
// шукаємо найменший елемент масиву з усіх, і тоді поміщаємо його ІНДЕКС в тимчасову змінну і тоді дані цього індексу міняємо з 0-м
// індексом, потім знову шукаємо найменші дані і цей індекс поміщаємо в тимчасову змінну і тоді вже дані цього індексу міняєм з 1- індексом 
// і так далі. Виходить, що масив починає сортуватися зліва на право - з меншого значення (зліва) до більшого (справа)
// можна також сортувати і навпаки з більшого до меншого, тоді ми шукаємо дані максимального індексу і міняємо їх з останнім індексом масиву
// і т. д.
//
//
//
//void main() {
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 10;
//	int arr_A[SIZE]{};
//	int min, minIndex = 0;
//	int count = 0;
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_A[i] = rand() % 50;          // заповнюєм масив
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";           // виводим невідсортований масив
//	}
//	cout << endl;
//
//
//	//-----------------------------------------алгоритм сортування----------------------------------
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		min = arr_A[i];             // присвоюєм мінімальне значення 0-му індексу масиву, потім 1-му, 2-му і т. д. оскільки
//		                            // 0-й, 1-й ... вже будуть відсортовані, нема сенсу їх перевіряти
//		minIndex = i;              // буде зберігатися індекс мінімального елемента
//		
//                                             //цикл для пошуку мінімального елемента
//		for (int j = i + 1; j < SIZE; j++)   // (j = i + 1) - тому що, нема сенсу порівнювати елемент сам з собою   
//		{
//			if (arr_A[j] < min)      // порівнюємо, якщо в індексі j, який рівний і+1 дані менші ніж в змінній min (= і)
//                    //то змінній minIndex присвоюєм індекс j, а в змінну min присвоюєм дані з індексом j - тимчасова змінна min (найменші дані)
//		// далі робимо заміну значень  - індексу з мінімальними даними (які вже в змінній min) ми присвоюєм дані з індексом "і" (самі ліві дані) 
//		// а лише потім в індекс "i", самий лівий, ми присвоюєм мінімальне значенн зі змінної min. і так далі. 
//
//						// (буде починатися так: якщо в індексі 1 (0+1) дані менші ніж в змінній min, яка рівна 0-му індексу
//				        // то змінній minIndex  присвоюєм індекс (j) (там лежать меніші дані ніж в індексі "і"), а в змінну min присвоюєм самі дані
//				        // з індексом "j". Збільшуєм "j" на +1 і проганяєм всі елементи масиву. В результаті в змінній min будуть найменші дані
//				        // а в змінній minIndex буде індекс з найменшими даними. Цим ми закінчили внутрішеій цикл. Далі в індекс де є найменші дані
//				        // minIndex поміщаємо дані з індексу "і" - 0-й індекс, а в 0-й індекс поміщаємо дані з min (найменші дані)
//				        // Все, 0-й елемент масиву відсортовано. Далі min знову присвоюєм дані з індексом "і" це вже буде 1-й індекс
//				        // а для minIndex присвоюєм сам індекс "і" це вже буде 1-ця. І знову по колу шукаємо найменші дані...
//			{
//				minIndex = j;    // індекс в якому лежать найменші дані
//				min = arr_A[j];  // найменші дані присвоюєм тимчасовій змінній min 
//			}
//			count++;          // просто счетчик іттерецій
//		}
//		arr_A[minIndex] = arr_A[i];  // заміна значень, в індекс з мінімальними даними переносим дані з 0-го індекса, 
//		                             //щоб потім туди перенести мінімальні дані
//		arr_A[i] = min;              // переносимо мінімальні дані в 0-й індекс
//
//		//swap(arr_A[minIndex], arr_A[i]); // можна просто використати функцію, яка міняє місцями "arr_A[minIndex]" та "arr_A[i]"
//	}
//
//
//
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";    // виводим відсортований масив
//	}
//	cout << endl;
//	cout << "Iterations - " << count << endl;
//	cout << "=============================" << endl;
//
//	system("Pause");
//}
//
//
//                                     ==================== СОРТУВАННЯ ВСТАВКОЮ ======================
//
//
//
//void main() {
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 10;
//	int arr_A[SIZE]{};
//	int key = 0;
//	int count = 0;
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_A[i] = rand() % 50;
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";
//	}
//
//
//	Сортування вставкою ***** Можна записати двома способами****************
//	 Ліва частина рахується як відсортована (0-1 індекс, потім 0-й і 1-й, потім 0-й, 1-й і 2-й і т. д.) і наступний елемент (невідсортованого масиву)
//	після відсортованого масиву береться і почергово порівнюється з елементами відсортованого масиву (справа на ліво) і коли, той елемент невідсортованого масиву
//	 шляхом порівняння знаходить своє місце в уже відсортованому, то ми берем наступний елемент невідсортованої частини масиву і знову почергово порівнюємо
//	 з елементами відсортованого масиву (шукаємо йому місце), і так поступово, доки весь масив не відсортуємо.
//	 Це найшвидчий спосіб з розглянутих
//
//
//	============================ 1-й спосіб =======================================
//
//	for (int i = 1; i < SIZE; i++)        //
//	{
//		key = i;                         // в змінну key по черзі присвоюєм кожен елемент масиву - "і", не пишемо прямо "і", то му що у внутрішньому циклі
//		                                 // будемо "і", тобто "key" кожен раз зменшувати, поки не порівняєм всі елементи
//
//		for (int j = i - 1; j >= 0; j--) // внутрішній цикл. "j" має завжди бути на 1 менше ніж "і", виконуєм доки j більше = 0, коли j стание -1 (j--) 
//		{                                // то цикл не виконається
//
//			if (arr_A[j] > arr_A[key])   // якщо "j" більше "і" (key), то міняємо місцями, дані з індексом "j" ставим на місце даних з індексом "і", і навпаки
//				                         
//			{
//				swap(arr_A[key], arr_A[j]); // міняємо місцями через функцію
//				key--;                      // індекс key зменшуєм на одиницю, щоб далі порівнювати. "j" зменшиться на 1 на початку цикла
//				                            // таким чином індекс "j" завжди буде на 1 менший за індекс "key", а коли "j" стане -1, то цикл не виконається
//			}
//			else                            // інакше якщо умова не виконується, то перериваємо цикл
//			{
//				break;
//			}
//			count++;              // Кількість іттерацій
//		}
//	}
//
//
//
//	============================ 2-й спосіб =======================================
//	використовуєм зовнішній цикл for (для переміщення п окожному елементу масива) і внутрішній - while (для порівняння двох елементів - 0-го і 1-го і т. д.)
//
//
//	for (int i = 1; i < SIZE; i++)
//	{
//
//		key = arr_A[i];
//		int j = i - 1;
//
//		while (j >= 0 && arr_A[j] > key) // якщо "j" більше рівне 0 і дані під індексом "j" більші даних під індексом "і" (змінна key), то міняєм місцями
//		{
//			arr_A[j + 1] = arr_A[j]; // заміняємо елементи місцями
//			arr_A[j] = key;           // можна використати функцію      swap(arr_A[j+1], arr_A[j]);    буде те саме.
//			j--;                      // зменшуєм "j", щоб рухатись по вже відсортованим елементам масиву, а коли "j" стає менше 0, то цикл while не виконується
//			count++;                  // рахуємо іттерації
//		}
//	}
//
//
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";              // виводим відсортований масив
//	}
//	cout << endl;
//	cout << endl;
//	cout << "Iterations - " << count << endl;
//	cout << "=============================" << endl;
//	system("Pause");
//}
//	
//
//
//
//
//
//
//                  ============== Порівняння трьох відів сортування (кількість іттерацій) =====================================
//
//
//void main() {
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 10;
//	int arr_A[SIZE]{};                       // Сортуєм вставкою
//	int arr_B[SIZE]{};                       // Сортуєм вибором
//	int arr_C[SIZE]{};                       // Сортуєм бульбашкою
//	int key = 0, min = 0, minIndex = 0;
//	int count = 0, count1 = 0, count2 = 0;
//	
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_A[i] = rand() % 100;                           // Запонюєм масив А
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_B[i] = arr_A[i];                             // Копіюємо те саме до масиву В
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_C[i] = arr_A[i];                             // Копіюємо те саме до масиву С
//	}
//
//	//======================================   Сортування вставкою   =======================================================
//
//	cout << "Insert:" << endl;
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";                         // Виводимо масив А до сортування
//	}
//
//	
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		key = i;
//
//		for (int j = i - 1; j >= 0; j--)
//		{
//			if (arr_A[j] > arr_A[key])
//			{
//				swap(arr_A[key], arr_A[j]);
//				key--;
//			}
//			else
//			{
//				break;
//			}
//			count++;                                    // Рахуємо кількість іттерацій
//		}
//	}
//	cout << endl;
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";                       // Виводимо відсортований масив А
//	}
//	cout << endl;
//	cout << endl;
//	cout << "Iterations - " << count << endl;
//	cout << "=============================" << endl;
//
//	===========================================   Сортування вибором   ===========================================
//
//	cout << "Select:" << endl;
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_B[i] << " ";                                 // Виводимо НЕ відсортований масив В
//	}
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//			{
//				min = arr_B[i];
//				minIndex = i;
//				
//				for (int j = i + 1; j < SIZE; j++)   
//				{
//					if (arr_B[j] < min)
//					{
//						minIndex = j;
//						min = arr_B[j];
//					}
//					count1++;                                         // Рахуємо кількість іттерацій
//				}
//				arr_B[minIndex] = arr_B[i];  
//				arr_B[i] = min;
//			}
//			for (int i = 0; i < SIZE; i++)
//			{
//				cout << arr_B[i] << " ";                                 // Виводимо відсортований масив В
//			}
//			cout << endl;
//			cout << endl;
//			cout << "Iterations - " << count1 << endl;
//			cout << "=============================" << endl;
//
//			//Сортування бульбашкою
//
//			cout << "Bubble:" << endl;
//			cout << endl;
//			bool c = true;
//
//			for (int i = 0; i < SIZE; i++)
//			{
//				cout << arr_C[i] << " ";                                // Виводимо НЕ відсортований масив С
//			}
//			cout << endl;
//
//			for (int i = 0; i < SIZE - 1; i++) {
//				c = true;
//				for (int j = 0; j < SIZE - i - 1; j++) {
//
//					if (arr_C[j] > arr_C[j + 1]) {
//						swap(arr_C[j], arr_C[j + 1]);
//
//						c = false;
//					}
//					count2++;
//				}
//				if (c) {
//					break;
//				}
//			}
//			
//			for (int i = 0; i < SIZE; i++)
//			{
//				cout << arr_C[i] << " ";                                // Виводимо відсортований масив С
//			}
//			cout << endl;
//			cout << endl;
//			cout << "Iterations - " << count2 << endl;
//			
//
//	system("Pause");
//}
//
//
//
// задача, є три масиви, перші два по 10 елементів, 3-й це сума 1-го і 2-го масивів. заповними 3-й маси, 
//Знайти його середнє значення елементів, мінімальний і максимальний єлементи
//
//void main() {
//	srand(unsigned(time(NULL)));
//
//	const int SIZE = 10;
//	int arr_A[SIZE]{};
//	int arr_B[SIZE]{};
//	int arr_C[SIZE]{};
//	int p = 0, max = arr_C[0], avg = 0;
//	int count = 0, count1 = 0, count2 = 0;
//	cout << "Insert:" << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		arr_A[i] = rand() % 30;
//		arr_B[i] = rand() % 30;
//		p = arr_A[i] + arr_B[i];
//		arr_C[i] = p;
//	}
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		avg += arr_C[i];
//	}
//	int min = arr_C[0];
//	for (int i = 0; i < SIZE; i++)
//	{
//		if (max < arr_C[i])
//		{
//			max = arr_C[i];
//		}
//
//		if (min > arr_C[i])
//		{
//			min = arr_C[i];
//		}
//	}
//	
//
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_A[i] << " ";
//	}
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_B[i] << " ";
//	}
//	cout << endl;
//	for (int i = 0; i < SIZE; i++)
//	{
//		cout << arr_C[i] << " ";
//	}
//	cout << endl;
//	cout << "AVG - " << avg/SIZE << endl;
//	cout << "Max - " << max << endl;
//	cout << "Min - " << min << endl;
//
//	system("Pause");
//}
//
//
//======================= ВІДЕО ========================================
//
//Bubble
//
//www.youtube.com/watch?v=lyZQPjUT5B4&t=242s 
//https://www.youtube.com/watch?v=nGV81F2vAdw
//
//Select
//
//www.youtube.com/watch?v=KZxP5JqtKKA 
//
//www.youtube.com/watch?v=Ns4TPTC8whw 
//
//https://www.youtube.com/watch?v=IZeSzcVM4XA&t=233s
//
//Insert
//
//www.youtube.com/watch?v=dAAkElskMmU 
//
//https://www.youtube.com/watch?v=tCYEr1uPQmg